<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Luna Map — Твой кусочек Луны</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&family=Share+Tech+Mono&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --gold: #c9a84c;
    --gold-dim: #8a6f2e;
    --bg: #050508;
    --text: #d4cfc4;
    --panel: rgba(8, 8, 14, 0.92);
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    cursor: grab;
  }
  body:active { cursor: grabbing; }

  #canvas-container {
    position: fixed;
    inset: 0;
  }

  /* Stars background */
  #stars {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
  }

  canvas { display: block; }

  /* Header */
  #header {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 10;
    padding: 24px 32px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    pointer-events: none;
    background: linear-gradient(to bottom, rgba(5,5,8,0.9) 0%, transparent 100%);
  }

  #logo {
    font-family: 'Cormorant Garamond', serif;
    font-weight: 300;
    font-size: 2rem;
    letter-spacing: 0.15em;
    color: var(--gold);
    line-height: 1;
    pointer-events: auto;
  }
  #logo span {
    display: block;
    font-size: 0.6rem;
    font-family: 'Share Tech Mono', monospace;
    letter-spacing: 0.4em;
    color: var(--gold-dim);
    margin-top: 4px;
  }

  #stats {
    text-align: right;
    font-size: 0.65rem;
    letter-spacing: 0.1em;
    color: var(--gold-dim);
    line-height: 2;
  }
  #stats b { color: var(--gold); font-weight: 400; }

  /* Controls hint */
  #hint {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    font-size: 0.6rem;
    letter-spacing: 0.25em;
    color: rgba(201, 168, 76, 0.35);
    text-transform: uppercase;
    pointer-events: none;
    animation: fadeHint 4s ease forwards;
    animation-delay: 2s;
  }
  @keyframes fadeHint {
    0% { opacity: 1; }
    100% { opacity: 0; }
  }

  /* Info panel */
  #panel {
    position: fixed;
    right: 0;
    top: 50%;
    transform: translateY(-50%) translateX(110%);
    z-index: 20;
    width: 280px;
    background: var(--panel);
    border-left: 1px solid rgba(201, 168, 76, 0.3);
    padding: 28px 24px;
    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    backdrop-filter: blur(20px);
  }
  #panel.open {
    transform: translateY(-50%) translateX(0);
  }

  #panel-close {
    position: absolute;
    top: 12px; right: 14px;
    background: none;
    border: none;
    color: var(--gold-dim);
    cursor: pointer;
    font-size: 1.2rem;
    line-height: 1;
    font-family: 'Share Tech Mono', monospace;
    transition: color 0.2s;
  }
  #panel-close:hover { color: var(--gold); }

  .panel-label {
    font-size: 0.55rem;
    letter-spacing: 0.3em;
    color: var(--gold-dim);
    text-transform: uppercase;
    margin-bottom: 6px;
  }

  .panel-value {
    font-family: 'Cormorant Garamond', serif;
    font-size: 1.4rem;
    color: var(--gold);
    margin-bottom: 20px;
    font-weight: 300;
  }

  .panel-coords {
    font-size: 0.65rem;
    color: var(--text);
    margin-bottom: 20px;
    line-height: 1.8;
    opacity: 0.7;
  }

  .panel-status {
    display: inline-block;
    padding: 4px 10px;
    border: 1px solid;
    font-size: 0.6rem;
    letter-spacing: 0.2em;
    margin-bottom: 24px;
  }
  .panel-status.free {
    border-color: #4caf7d;
    color: #4caf7d;
  }
  .panel-status.sold {
    border-color: #c94c4c;
    color: #c94c4c;
  }

  #btn-buy {
    display: block;
    width: 100%;
    padding: 14px;
    background: transparent;
    border: 1px solid var(--gold);
    color: var(--gold);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.75rem;
    letter-spacing: 0.2em;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
  }
  #btn-buy:hover {
    background: var(--gold);
    color: var(--bg);
  }
  #btn-buy:disabled {
    border-color: #444;
    color: #444;
    cursor: not-allowed;
  }
  #btn-buy:disabled:hover {
    background: transparent;
    color: #444;
  }

  /* Loading */
  #loading {
    position: fixed;
    inset: 0;
    z-index: 100;
    background: var(--bg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: opacity 0.8s ease;
  }
  #loading.hidden {
    opacity: 0;
    pointer-events: none;
  }
  #loading-title {
    font-family: 'Cormorant Garamond', serif;
    font-size: 3rem;
    font-weight: 300;
    color: var(--gold);
    letter-spacing: 0.2em;
    margin-bottom: 8px;
  }
  #loading-sub {
    font-size: 0.6rem;
    letter-spacing: 0.4em;
    color: var(--gold-dim);
    margin-bottom: 40px;
  }
  #loading-bar-wrap {
    width: 200px;
    height: 1px;
    background: rgba(201, 168, 76, 0.15);
    position: relative;
    overflow: hidden;
  }
  #loading-bar {
    position: absolute;
    left: -100%;
    top: 0;
    width: 100%;
    height: 100%;
    background: var(--gold);
    animation: loadBar 1.8s ease infinite;
  }
  @keyframes loadBar {
    0% { left: -100%; }
    50% { left: 0; }
    100% { left: 100%; }
  }

  /* Tooltip */
  #tooltip {
    position: fixed;
    z-index: 15;
    background: rgba(8,8,14,0.85);
    border: 1px solid rgba(201,168,76,0.3);
    padding: 6px 12px;
    font-size: 0.62rem;
    letter-spacing: 0.1em;
    color: var(--gold);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    backdrop-filter: blur(8px);
  }
  #tooltip.show { opacity: 1; }

  /* Zoom controls */
  #zoom-controls {
    position: fixed;
    left: 24px;
    bottom: 24px;
    z-index: 10;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }
  .zoom-btn {
    width: 32px;
    height: 32px;
    background: var(--panel);
    border: 1px solid rgba(201,168,76,0.25);
    color: var(--gold);
    font-size: 1.1rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    font-family: monospace;
    backdrop-filter: blur(10px);
  }
  .zoom-btn:hover {
    border-color: var(--gold);
    background: rgba(201,168,76,0.1);
  }
</style>
</head>
<body>

<div id="loading">
  <div id="loading-title">LUNA</div>
  <div id="loading-sub">ЗАГРУЗКА КАРТЫ ПОВЕРХНОСТИ</div>
  <div id="loading-bar-wrap"><div id="loading-bar"></div></div>
</div>

<canvas id="stars"></canvas>
<div id="canvas-container"></div>

<div id="header">
  <div id="logo">
    Luna Map
    <span>реестр лунной поверхности</span>
  </div>
  <div id="stats">
    Участков всего: <b id="stat-total">3240</b><br>
    Свободно: <b id="stat-free">3197</b><br>
    Продано: <b id="stat-sold">43</b>
  </div>
</div>

<div id="tooltip"></div>

<div id="panel">
  <button id="panel-close">×</button>
  <div class="panel-label">Регион</div>
  <div class="panel-value" id="p-region">—</div>
  <div class="panel-label">Участок</div>
  <div class="panel-value" id="p-id">—</div>
  <div class="panel-coords" id="p-coords">—</div>
  <div class="panel-status free" id="p-status">СВОБОДЕН</div>
  <br>
  <button id="btn-buy">Получить сертификат</button>
</div>

<div id="zoom-controls">
  <button class="zoom-btn" id="zoom-in">+</button>
  <button class="zoom-btn" id="zoom-out">−</button>
</div>

<div id="hint">перетаскивай · прокручивай для зума · нажимай на участок</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ─── Stars canvas ──────────────────────────────────────────────────────────
const starsCanvas = document.getElementById('stars');
const sCtx = starsCanvas.getContext('2d');
let starsData = [];

function initStars() {
  starsCanvas.width = window.innerWidth;
  starsCanvas.height = window.innerHeight;
  starsData = [];
  for (let i = 0; i < 500; i++) {
    starsData.push({
      x: Math.random() * starsCanvas.width,
      y: Math.random() * starsCanvas.height,
      r: Math.random() * 1.2,
      a: Math.random()
    });
  }
  sCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
  starsData.forEach(s => {
    sCtx.beginPath();
    sCtx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    sCtx.fillStyle = `rgba(255,255,255,${s.a})`;
    sCtx.fill();
  });
}
initStars();

// ─── Three.js setup ────────────────────────────────────────────────────────
const container = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000, 0);
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.z = 2.8;

// Lighting
const ambient = new THREE.AmbientLight(0xffffff, 0.15);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xfff5e0, 1.1);
sun.position.set(5, 3, 5);
scene.add(sun);
const fill = new THREE.DirectionalLight(0x2244aa, 0.08);
fill.position.set(-5, -2, -3);
scene.add(fill);

// Moon globe
const moonGeo = new THREE.SphereGeometry(1, 64, 64);

// Load moon texture from NASA public domain
const loader = new THREE.TextureLoader();
let moonMesh;

// Regions on the moon
const REGIONS = [
  "Море Спокойствия", "Море Ясности", "Море Дождей", "Океан Бурь",
  "Море Кризисов", "Море Изобилия", "Море Нектара", "Море Холода",
  "Нагорье Кеплера", "Равнина Декарта", "Кратер Тихо", "Кратер Коперник",
  "Море Краевое", "Море Москвы", "Залив Росы", "Залив Радуги"
];

// Sold parcels simulation (random few)
const soldParcels = new Set();
for (let i = 0; i < 43; i++) {
  soldParcels.add(Math.floor(Math.random() * 3240));
}

function createMoon(texture) {
  const mat = new THREE.MeshPhongMaterial({
    map: texture,
    bumpScale: 0.005,
    specular: new THREE.Color(0x111111),
    shininess: 5,
  });
  moonMesh = new THREE.Mesh(moonGeo, mat);
  scene.add(moonMesh);

  // Grid overlay
  createGrid();
  hideLoading();
}

// Try loading NASA texture, fallback to procedural
loader.load(
  'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/FullMoon2010.jpg/1280px-FullMoon2010.jpg',
  tex => createMoon(tex),
  undefined,
  () => {
    // Fallback: gray procedural moon
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    const grd = ctx.createRadialGradient(256, 128, 10, 256, 128, 280);
    grd.addColorStop(0, '#c8c0b0');
    grd.addColorStop(0.4, '#a89880');
    grd.addColorStop(0.7, '#908070');
    grd.addColorStop(1, '#706050');
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, 512, 256);
    // Add some noise
    for (let i = 0; i < 2000; i++) {
      const x = Math.random() * 512, y = Math.random() * 256;
      const r = Math.random() * 3;
      const a = Math.random() * 0.3;
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fillStyle = `rgba(0,0,0,${a})`;
      ctx.fill();
    }
    const tex = new THREE.CanvasTexture(canvas);
    createMoon(tex);
  }
);

// ─── Grid ──────────────────────────────────────────────────────────────────
const GRID_COLS = 60;
const GRID_ROWS = 54;
let gridLines;

function createGrid() {
  const mat = new THREE.LineBasicMaterial({
    color: 0xc9a84c,
    transparent: true,
    opacity: 0.18,
  });
  const group = new THREE.Group();

  // Latitude lines
  for (let r = 0; r <= GRID_ROWS; r++) {
    const lat = (r / GRID_ROWS) * Math.PI - Math.PI / 2;
    const pts = [];
    for (let c = 0; c <= 128; c++) {
      const lon = (c / 128) * Math.PI * 2;
      pts.push(new THREE.Vector3(
        1.001 * Math.cos(lat) * Math.cos(lon),
        1.001 * Math.sin(lat),
        1.001 * Math.cos(lat) * Math.sin(lon)
      ));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    group.add(new THREE.Line(geo, mat));
  }

  // Longitude lines
  for (let c = 0; c < GRID_COLS; c++) {
    const lon = (c / GRID_COLS) * Math.PI * 2;
    const pts = [];
    for (let r = 0; r <= 64; r++) {
      const lat = (r / 64) * Math.PI - Math.PI / 2;
      pts.push(new THREE.Vector3(
        1.001 * Math.cos(lat) * Math.cos(lon),
        1.001 * Math.sin(lat),
        1.001 * Math.cos(lat) * Math.sin(lon)
      ));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    group.add(new THREE.Line(geo, mat));
  }

  scene.add(group);
  gridLines = group;
}

// Highlighted parcel
let highlightMesh = null;

function highlightParcel(col, row) {
  if (highlightMesh) { scene.remove(highlightMesh); highlightMesh = null; }

  const latMin = (row / GRID_ROWS) * Math.PI - Math.PI / 2;
  const latMax = ((row + 1) / GRID_ROWS) * Math.PI - Math.PI / 2;
  const lonMin = (col / GRID_COLS) * Math.PI * 2;
  const lonMax = ((col + 1) / GRID_COLS) * Math.PI * 2;

  const pts = [];
  const steps = 24;
  // Bottom edge
  for (let i = 0; i <= steps; i++) pts.push(latLonToVec(latMin, lonMin + (lonMax - lonMin) * i / steps, 1.003));
  // Right edge
  for (let i = 0; i <= steps; i++) pts.push(latLonToVec(latMin + (latMax - latMin) * i / steps, lonMax, 1.003));
  // Top edge
  for (let i = steps; i >= 0; i--) pts.push(latLonToVec(latMax, lonMin + (lonMax - lonMin) * i / steps, 1.003));
  // Left edge
  for (let i = steps; i >= 0; i--) pts.push(latLonToVec(latMin + (latMax - latMin) * i / steps, lonMin, 1.003));
  pts.push(pts[0]);

  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.9 });
  highlightMesh = new THREE.Line(geo, mat);
  scene.add(highlightMesh);
}

function latLonToVec(lat, lon, r = 1) {
  return new THREE.Vector3(
    r * Math.cos(lat) * Math.cos(lon),
    r * Math.sin(lat),
    r * Math.cos(lat) * Math.sin(lon)
  );
}

// ─── Interaction ───────────────────────────────────────────────────────────
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const tooltip = document.getElementById('tooltip');
const panel = document.getElementById('panel');

let isDragging = false;
let prevMouse = { x: 0, y: 0 };
let rotVel = { x: 0, y: 0 };
let selectedParcel = null;

function getParcelFromIntersect(point) {
  // Convert world point to lat/lon
  const normalized = point.clone().normalize();
  const lat = Math.asin(normalized.y);
  let lon = Math.atan2(normalized.z, normalized.x);
  if (lon < 0) lon += Math.PI * 2;

  const col = Math.floor((lon / (Math.PI * 2)) * GRID_COLS);
  const row = Math.floor(((lat + Math.PI / 2) / Math.PI) * GRID_ROWS);
  return { col, row };
}

function parcelId(col, row) {
  return row * GRID_COLS + col;
}

function parcelName(col, row) {
  const id = parcelId(col, row);
  const regionIdx = Math.floor(id / (3240 / REGIONS.length)) % REGIONS.length;
  const num = (id % 100 + 1).toString().padStart(3, '0');
  return { region: REGIONS[regionIdx], code: `LUN-${(id + 1000).toString(16).toUpperCase()}` };
}

function latLonLabel(col, row) {
  const latDeg = (((row + 0.5) / GRID_ROWS) * 180 - 90).toFixed(1);
  const lonDeg = (((col + 0.5) / GRID_COLS) * 360).toFixed(1);
  const latDir = latDeg >= 0 ? 'N' : 'S';
  const lonDir = lonDeg <= 180 ? 'E' : 'W';
  return `${Math.abs(latDeg)}°${latDir}  ${lonDeg <= 180 ? lonDeg : (360 - lonDeg).toFixed(1)}°${lonDir}`;
}

renderer.domElement.addEventListener('mousemove', e => {
  if (isDragging) {
    const dx = e.clientX - prevMouse.x;
    const dy = e.clientY - prevMouse.y;
    rotVel.x = dy * 0.004;
    rotVel.y = dx * 0.004;
    if (moonMesh) {
      moonMesh.rotation.x += rotVel.x;
      moonMesh.rotation.y += rotVel.y;
      if (gridLines) { gridLines.rotation.copy(moonMesh.rotation); }
      if (highlightMesh) { highlightMesh.rotation.copy(moonMesh.rotation); }
    }
    prevMouse = { x: e.clientX, y: e.clientY };
    tooltip.classList.remove('show');
    return;
  }

  if (!moonMesh) return;

  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObject(moonMesh);
  if (hits.length > 0) {
    const { col, row } = getParcelFromIntersect(hits[0].point.clone().applyEuler(new THREE.Euler(-moonMesh.rotation.x, -moonMesh.rotation.y, -moonMesh.rotation.z, 'XYZ')));
    const { code } = parcelName(col, row);
    const id = parcelId(col, row);
    tooltip.style.left = (e.clientX + 14) + 'px';
    tooltip.style.top = (e.clientY - 20) + 'px';
    tooltip.textContent = code + (soldParcels.has(id) ? ' · ПРОДАН' : ' · свободен');
    tooltip.classList.add('show');
    document.body.style.cursor = 'pointer';
  } else {
    tooltip.classList.remove('show');
    document.body.style.cursor = isDragging ? 'grabbing' : 'grab';
  }
});

renderer.domElement.addEventListener('mousedown', e => {
  isDragging = false;
  prevMouse = { x: e.clientX, y: e.clientY };
  renderer.domElement.addEventListener('mousemove', startDrag);
  renderer.domElement.addEventListener('mouseup', endDrag);
});

function startDrag(e) {
  const dx = e.clientX - prevMouse.x;
  const dy = e.clientY - prevMouse.y;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) isDragging = true;
}

function endDrag(e) {
  renderer.domElement.removeEventListener('mousemove', startDrag);
  renderer.domElement.removeEventListener('mouseup', endDrag);
  if (!isDragging) handleClick(e);
  isDragging = false;
  document.body.style.cursor = 'grab';
}

function handleClick(e) {
  if (!moonMesh) return;
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObject(moonMesh);
  if (hits.length === 0) return;

  const worldPoint = hits[0].point.clone();
  const localPoint = worldPoint.clone().applyEuler(new THREE.Euler(
    -moonMesh.rotation.x, -moonMesh.rotation.y, -moonMesh.rotation.z, 'XYZ'
  ));
  const { col, row } = getParcelFromIntersect(localPoint);
  const id = parcelId(col, row);
  const { region, code } = parcelName(col, row);
  const isSold = soldParcels.has(id);

  highlightParcel(col, row);
  if (highlightMesh) highlightMesh.rotation.copy(moonMesh.rotation);

  document.getElementById('p-region').textContent = region;
  document.getElementById('p-id').textContent = code;
  document.getElementById('p-coords').textContent =
    `Координаты: ${latLonLabel(col, row)}\nПлощадь: ~${(3793 * Math.PI * 4 / 3240).toFixed(0)} км²`;
  const statusEl = document.getElementById('p-status');
  statusEl.textContent = isSold ? 'ПРОДАН' : 'СВОБОДЕН';
  statusEl.className = 'panel-status ' + (isSold ? 'sold' : 'free');
  const buyBtn = document.getElementById('btn-buy');
  buyBtn.disabled = isSold;

  selectedParcel = { col, row, code, region };
  panel.classList.add('open');
}

// Scroll zoom
renderer.domElement.addEventListener('wheel', e => {
  camera.position.z = Math.max(1.5, Math.min(5, camera.position.z + e.deltaY * 0.002));
});

// Zoom buttons
document.getElementById('zoom-in').addEventListener('click', () => {
  camera.position.z = Math.max(1.5, camera.position.z - 0.3);
});
document.getElementById('zoom-out').addEventListener('click', () => {
  camera.position.z = Math.min(5, camera.position.z + 0.3);
});

// Panel close
document.getElementById('panel-close').addEventListener('click', () => {
  panel.classList.remove('open');
  if (highlightMesh) { scene.remove(highlightMesh); highlightMesh = null; }
});

// Touch support
let touchStart = null;
renderer.domElement.addEventListener('touchstart', e => {
  touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() };
}, { passive: true });

renderer.domElement.addEventListener('touchmove', e => {
  if (!touchStart || !moonMesh) return;
  const dx = e.touches[0].clientX - touchStart.x;
  const dy = e.touches[0].clientY - touchStart.y;
  moonMesh.rotation.y += dx * 0.006;
  moonMesh.rotation.x += dy * 0.006;
  if (gridLines) gridLines.rotation.copy(moonMesh.rotation);
  if (highlightMesh) highlightMesh.rotation.copy(moonMesh.rotation);
  touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY, time: touchStart.time };
}, { passive: true });

// Buy button placeholder
document.getElementById('btn-buy').addEventListener('click', () => {
  if (!selectedParcel) return;
  alert(`Сертификат на участок ${selectedParcel.code} в районе "${selectedParcel.region}" — скоро здесь будет оплата через Telegram!`);
});

// ─── Slow auto-rotate ──────────────────────────────────────────────────────
let autoRotate = true;
renderer.domElement.addEventListener('mousedown', () => { autoRotate = false; });

// ─── Resize ────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  initStars();
});

// ─── Loading hide ──────────────────────────────────────────────────────────
function hideLoading() {
  const el = document.getElementById('loading');
  setTimeout(() => el.classList.add('hidden'), 400);
  setTimeout(() => el.remove(), 1200);
}

// ─── Render loop ───────────────────────────────────────────────────────────
function animate() {
  requestAnimationFrame(animate);
  if (moonMesh && autoRotate) {
    moonMesh.rotation.y += 0.0008;
    if (gridLines) gridLines.rotation.copy(moonMesh.rotation);
    if (highlightMesh) highlightMesh.rotation.copy(moonMesh.rotation);
  }
  // Dampen velocity
  rotVel.x *= 0.92;
  rotVel.y *= 0.92;
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
